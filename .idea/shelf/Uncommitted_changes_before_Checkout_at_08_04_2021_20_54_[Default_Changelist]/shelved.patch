Index: app/src/main/java/com/example/kodama/controllers/Camera2BasicFragment.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.kodama.controllers;\r\n\r\nimport android.app.Activity;\r\nimport android.app.AlertDialog;\r\nimport android.app.Dialog;\r\nimport android.app.DialogFragment;\r\nimport android.app.Fragment;\r\nimport android.content.Context;\r\nimport android.content.DialogInterface;\r\nimport android.content.pm.PackageInfo;\r\nimport android.content.pm.PackageManager;\r\nimport android.content.res.Configuration;\r\nimport android.graphics.Bitmap;\r\nimport android.graphics.ImageFormat;\r\nimport android.graphics.Matrix;\r\nimport android.graphics.Point;\r\nimport android.graphics.RectF;\r\nimport android.graphics.SurfaceTexture;\r\nimport android.hardware.camera2.CameraAccessException;\r\nimport android.hardware.camera2.CameraCaptureSession;\r\nimport android.hardware.camera2.CameraCharacteristics;\r\nimport android.hardware.camera2.CameraDevice;\r\nimport android.hardware.camera2.CameraManager;\r\nimport android.hardware.camera2.CaptureRequest;\r\nimport android.hardware.camera2.CaptureResult;\r\nimport android.hardware.camera2.TotalCaptureResult;\r\nimport android.hardware.camera2.params.StreamConfigurationMap;\r\nimport android.media.ImageReader;\r\nimport android.os.Bundle;\r\nimport android.os.Handler;\r\nimport android.os.HandlerThread;\r\nimport android.os.Process;\r\nimport android.support.annotation.NonNull;\r\nimport android.text.SpannableString;\r\nimport android.text.SpannableStringBuilder;\r\nimport android.util.Log;\r\nimport android.util.Size;\r\nimport android.view.LayoutInflater;\r\nimport android.view.Surface;\r\nimport android.view.TextureView;\r\nimport android.view.View;\r\nimport android.view.ViewGroup;\r\nimport android.widget.AdapterView;\r\nimport android.widget.ArrayAdapter;\r\nimport android.widget.ListView;\r\nimport android.widget.NumberPicker;\r\nimport android.widget.TextView;\r\nimport android.widget.Toast;\r\nimport android.support.v13.app.FragmentCompat;\r\n\r\nimport com.example.kodama.view.AutoFitTextureView;\r\n\r\nimport java.io.IOException;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.Collections;\r\nimport java.util.Comparator;\r\nimport java.util.List;\r\nimport java.util.concurrent.Semaphore;\r\nimport java.util.concurrent.TimeUnit;\r\n\r\n/** Basic fragments for the Camera. */\r\npublic class Camera2BasicFragment extends Fragment\r\n        implements FragmentCompat.OnRequestPermissionsResultCallback {\r\n\r\n    /** Tag for the {@link Log}. */\r\n    private static final String TAG = \"TfLiteCameraDemo\";\r\n\r\n    private static final String FRAGMENT_DIALOG = \"dialog\";\r\n\r\n    private static final String HANDLE_THREAD_NAME = \"CameraBackground\";\r\n\r\n    private static final int PERMISSIONS_REQUEST_CODE = 1;\r\n\r\n    private final Object lock = new Object();\r\n    private boolean runClassifier = false;\r\n    private boolean checkedPermissions = false;\r\n    private TextView textView;\r\n    private NumberPicker np;\r\n    private ImageClassifier classifier;\r\n    private ListView deviceView;\r\n    private ListView modelView;\r\n\r\n\r\n    /** Max preview width that is guaranteed by Camera2 API */\r\n    private static final int MAX_PREVIEW_WIDTH = 1920;\r\n\r\n    /** Max preview height that is guaranteed by Camera2 API */\r\n    private static final int MAX_PREVIEW_HEIGHT = 1080;\r\n\r\n    /**\r\n     * {@link TextureView.SurfaceTextureListener} handles several lifecycle events on a {@link\r\n     * TextureView}.\r\n     */\r\n    private final TextureView.SurfaceTextureListener surfaceTextureListener =\r\n            new TextureView.SurfaceTextureListener() {\r\n\r\n                @Override\r\n                public void onSurfaceTextureAvailable(SurfaceTexture texture, int width, int height) {\r\n                    openCamera(width, height);\r\n                }\r\n\r\n                @Override\r\n                public void onSurfaceTextureSizeChanged(SurfaceTexture texture, int width, int height) {\r\n                    configureTransform(width, height);\r\n                }\r\n\r\n                @Override\r\n                public boolean onSurfaceTextureDestroyed(SurfaceTexture texture) {\r\n                    return true;\r\n                }\r\n\r\n                @Override\r\n                public void onSurfaceTextureUpdated(SurfaceTexture texture) {}\r\n            };\r\n\r\n    // Model parameter constants.\r\n    private String gpu;\r\n    private String cpu;\r\n    private String nnApi;\r\n    private String mobilenetV1Quant;\r\n    private String mobilenetV1Float;\r\n\r\n\r\n\r\n    /** ID of the current {@link CameraDevice}. */\r\n    private String cameraId;\r\n\r\n    /** An {@link AutoFitTextureView} for camera preview. */\r\n    private AutoFitTextureView textureView;\r\n\r\n    /** A {@link CameraCaptureSession } for camera preview. */\r\n    private CameraCaptureSession captureSession;\r\n\r\n    /** A reference to the opened {@link CameraDevice}. */\r\n    private CameraDevice cameraDevice;\r\n\r\n    /** The {@link android.util.Size} of camera preview. */\r\n    private Size previewSize;\r\n\r\n    /** {@link CameraDevice.StateCallback} is called when {@link CameraDevice} changes its state. */\r\n    private final CameraDevice.StateCallback stateCallback =\r\n            new CameraDevice.StateCallback() {\r\n\r\n                @Override\r\n                public void onOpened(@NonNull CameraDevice currentCameraDevice) {\r\n                    // This method is called when the camera is opened.  We start camera preview here.\r\n                    cameraOpenCloseLock.release();\r\n                    cameraDevice = currentCameraDevice;\r\n                    createCameraPreviewSession();\r\n                }\r\n\r\n                @Override\r\n                public void onDisconnected(@NonNull CameraDevice currentCameraDevice) {\r\n                    cameraOpenCloseLock.release();\r\n                    currentCameraDevice.close();\r\n                    cameraDevice = null;\r\n                }\r\n\r\n                @Override\r\n                public void onError(@NonNull CameraDevice currentCameraDevice, int error) {\r\n                    cameraOpenCloseLock.release();\r\n                    currentCameraDevice.close();\r\n                    cameraDevice = null;\r\n                    Activity activity = getActivity();\r\n                    if (null != activity) {\r\n                        activity.finish();\r\n                    }\r\n                }\r\n            };\r\n\r\n    private ArrayList<String> deviceStrings = new ArrayList<String>();\r\n    private ArrayList<String> modelStrings = new ArrayList<String>();\r\n\r\n    /** Current indices of device and model. */\r\n    int currentDevice = -1;\r\n\r\n    int currentModel = -1;\r\n\r\n    int currentNumThreads = -1;\r\n\r\n    /** An additional thread for running tasks that shouldn't block the UI. */\r\n    private HandlerThread backgroundThread;\r\n\r\n    /** A {@link Handler} for running tasks in the background. */\r\n    private Handler backgroundHandler;\r\n\r\n    /** An {@link ImageReader} that handles image capture. */\r\n    private ImageReader imageReader;\r\n\r\n    /** {@link CaptureRequest.Builder} for the camera preview */\r\n    private CaptureRequest.Builder previewRequestBuilder;\r\n\r\n    /** {@link CaptureRequest} generated by {@link #previewRequestBuilder} */\r\n    private CaptureRequest previewRequest;\r\n\r\n    /** A {@link Semaphore} to prevent the app from exiting before closing the camera. */\r\n    private Semaphore cameraOpenCloseLock = new Semaphore(1);\r\n\r\n    /** A {@link CameraCaptureSession.CaptureCallback} that handles events related to capture. */\r\n    private CameraCaptureSession.CaptureCallback captureCallback =\r\n            new CameraCaptureSession.CaptureCallback() {\r\n\r\n                @Override\r\n                public void onCaptureProgressed(\r\n                        @NonNull CameraCaptureSession session,\r\n                        @NonNull CaptureRequest request,\r\n                        @NonNull CaptureResult partialResult) {}\r\n\r\n                @Override\r\n                public void onCaptureCompleted(\r\n                        @NonNull CameraCaptureSession session,\r\n                        @NonNull CaptureRequest request,\r\n                        @NonNull TotalCaptureResult result) {}\r\n            };\r\n\r\n    /**\r\n     * Shows a {@link Toast} on the UI thread for the classification results.\r\n     *\r\n     * @param text The message to show\r\n     */\r\n    private void showToast(String s) {\r\n        SpannableStringBuilder builder = new SpannableStringBuilder();\r\n        SpannableString str1 = new SpannableString(s);\r\n        builder.append(str1);\r\n        showToast(builder);\r\n    }\r\n\r\n    private void showToast(SpannableStringBuilder builder) {\r\n        final Activity activity = getActivity();\r\n        if (activity != null) {\r\n            activity.runOnUiThread(\r\n                    new Runnable() {\r\n                        @Override\r\n                        public void run() {\r\n                            textView.setText(builder, TextView.BufferType.SPANNABLE);\r\n                        }\r\n                    });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resizes image.\r\n     *\r\n     * Attempting to use too large a preview size could  exceed the camera bus' bandwidth limitation,\r\n     * resulting in gorgeous previews but the storage of garbage capture data.\r\n     *\r\n     * Given {@code choices} of {@code Size}s supported by a camera, choose the smallest one that is\r\n     * at least as large as the respective texture view size, and that is at most as large as the\r\n     * respective max size, and whose aspect ratio matches with the specified value. If such size\r\n     * doesn't exist, choose the largest one that is at most as large as the respective max size, and\r\n     * whose aspect ratio matches with the specified value.\r\n     *\r\n     * @param choices The list of sizes that the camera supports for the intended output class\r\n     * @param textureViewWidth The width of the texture view relative to sensor coordinate\r\n     * @param textureViewHeight The height of the texture view relative to sensor coordinate\r\n     * @param maxWidth The maximum width that can be chosen\r\n     * @param maxHeight The maximum height that can be chosen\r\n     * @param aspectRatio The aspect ratio\r\n     * @return The optimal {@code Size}, or an arbitrary one if none were big enough\r\n     */\r\n    private static Size chooseOptimalSize(\r\n            Size[] choices,\r\n            int textureViewWidth,\r\n            int textureViewHeight,\r\n            int maxWidth,\r\n            int maxHeight,\r\n            Size aspectRatio) {\r\n\r\n        // Collect the supported resolutions that are at least as big as the preview Surface\r\n        List<Size> bigEnough = new ArrayList<>();\r\n        // Collect the supported resolutions that are smaller than the preview Surface\r\n        List<Size> notBigEnough = new ArrayList<>();\r\n        int w = aspectRatio.getWidth();\r\n        int h = aspectRatio.getHeight();\r\n        for (Size option : choices) {\r\n            if (option.getWidth() <= maxWidth\r\n                    && option.getHeight() <= maxHeight\r\n                    && option.getHeight() == option.getWidth() * h / w) {\r\n                if (option.getWidth() >= textureViewWidth && option.getHeight() >= textureViewHeight) {\r\n                    bigEnough.add(option);\r\n                } else {\r\n                    notBigEnough.add(option);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Pick the smallest of those big enough. If there is no one big enough, pick the\r\n        // largest of those not big enough.\r\n        if (bigEnough.size() > 0) {\r\n            return Collections.min(bigEnough, new CompareSizesByArea());\r\n        } else if (notBigEnough.size() > 0) {\r\n            return Collections.max(notBigEnough, new CompareSizesByArea());\r\n        } else {\r\n            Log.e(TAG, \"Couldn't find any suitable preview size\");\r\n            return choices[0];\r\n        }\r\n    }\r\n\r\n    public static Camera2BasicFragment newInstance() {\r\n        return new Camera2BasicFragment();\r\n    }\r\n\r\n    /** Layout the preview and buttons. */\r\n    @Override\r\n    public View onCreateView(\r\n            LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\r\n        return inflater.inflate(R.layout.fragment_camera2_basic, container, false);\r\n    }\r\n\r\n    private void updateActiveModel() {\r\n        // Get UI information before delegating to background\r\n        final int modelIndex = modelView.getCheckedItemPosition();\r\n        final int deviceIndex = deviceView.getCheckedItemPosition();\r\n        final int numThreads = np.getValue();\r\n\r\n        backgroundHandler.post(\r\n                () -> {\r\n                    if (modelIndex == currentModel\r\n                            && deviceIndex == currentDevice\r\n                            && numThreads == currentNumThreads) {\r\n                        return;\r\n                    }\r\n                    currentModel = modelIndex;\r\n                    currentDevice = deviceIndex;\r\n                    currentNumThreads = numThreads;\r\n\r\n                    // Disable classifier while updating\r\n                    if (classifier != null) {\r\n                        classifier.close();\r\n                        classifier = null;\r\n                    }\r\n\r\n                    // Lookup names of parameters.\r\n                    String model = modelStrings.get(modelIndex);\r\n                    String device = deviceStrings.get(deviceIndex);\r\n\r\n                    Log.i(TAG, \"Changing model to \" + model + \" device \" + device);\r\n\r\n                    // Try to load model.\r\n                    try {\r\n                        if (model.equals(mobilenetV1Quant)) {\r\n                            classifier = new ImageClassifierQuantizedMobileNet(getActivity());\r\n                        } else if (model.equals(mobilenetV1Float)) {\r\n                            classifier = new ImageClassifierFloatMobileNet(getActivity());\r\n                        } else {\r\n                            showToast(\"Failed to load model\");\r\n                        }\r\n                    } catch (IOException e) {\r\n                        Log.d(TAG, \"Failed to load\", e);\r\n                        classifier = null;\r\n                    }\r\n\r\n                    // Customize the interpreter to the type of device we want to use.\r\n                    if (classifier == null) {\r\n                        return;\r\n                    }\r\n                    classifier.setNumThreads(numThreads);\r\n                    if (device.equals(cpu)) {\r\n                    } else if (device.equals(gpu)) {\r\n                        classifier.useGpu();\r\n                    } else if (device.equals(nnApi)) {\r\n                        classifier.useNNAPI();\r\n                    }\r\n                });\r\n    }\r\n\r\n    /** Connect the buttons to their event handler. */\r\n    @Override\r\n    public void onViewCreated(final View view, Bundle savedInstanceState) {\r\n        gpu = getString(R.string.gpu);\r\n        cpu = getString(R.string.cpu);\r\n        nnApi = getString(R.string.nnapi);\r\n        mobilenetV1Quant = getString(R.string.mobilenetV1Quant);\r\n        mobilenetV1Float = getString(R.string.mobilenetV1Float);\r\n\r\n        // Get references to widgets.\r\n        textureView = (AutoFitTextureView) view.findViewById(R.id.texture);\r\n        textView = (TextView) view.findViewById(R.id.text);\r\n        deviceView = (ListView) view.findViewById(R.id.device);\r\n        modelView = (ListView) view.findViewById(R.id.model);\r\n\r\n        // Build list of models\r\n        modelStrings.add(mobilenetV1Quant);\r\n        modelStrings.add(mobilenetV1Float);\r\n\r\n        // Build list of devices\r\n        int defaultModelIndex = 0;\r\n        deviceStrings.add(cpu);\r\n        deviceStrings.add(gpu);\r\n        deviceStrings.add(nnApi);\r\n\r\n        deviceView.setAdapter(\r\n                new ArrayAdapter<String>(\r\n                        getContext(), R.layout.listview_row, R.id.listview_row_text, deviceStrings));\r\n        deviceView.setChoiceMode(ListView.CHOICE_MODE_SINGLE);\r\n        deviceView.setOnItemClickListener(\r\n                new AdapterView.OnItemClickListener() {\r\n                    @Override\r\n                    public void onItemClick(AdapterView<?> parent, View view, int position, long id) {\r\n                        updateActiveModel();\r\n                    }\r\n                });\r\n        deviceView.setItemChecked(0, true);\r\n\r\n        modelView.setChoiceMode(ListView.CHOICE_MODE_SINGLE);\r\n        ArrayAdapter<String> modelAdapter =\r\n                new ArrayAdapter<>(\r\n                        getContext(), R.layout.listview_row, R.id.listview_row_text, modelStrings);\r\n        modelView.setAdapter(modelAdapter);\r\n        modelView.setItemChecked(defaultModelIndex, true);\r\n        modelView.setOnItemClickListener(\r\n                new AdapterView.OnItemClickListener() {\r\n                    @Override\r\n                    public void onItemClick(AdapterView<?> parent, View view, int position, long id) {\r\n                        updateActiveModel();\r\n                    }\r\n                });\r\n\r\n        np = (NumberPicker) view.findViewById(R.id.np);\r\n        np.setMinValue(1);\r\n        np.setMaxValue(10);\r\n        np.setWrapSelectorWheel(true);\r\n        np.setOnValueChangedListener(\r\n                new NumberPicker.OnValueChangeListener() {\r\n                    @Override\r\n                    public void onValueChange(NumberPicker picker, int oldVal, int newVal) {\r\n                        updateActiveModel();\r\n                    }\r\n                });\r\n\r\n        // Start initial model.\r\n    }\r\n\r\n    /** Load the model and labels. */\r\n    @Override\r\n    public void onActivityCreated(Bundle savedInstanceState) {\r\n        super.onActivityCreated(savedInstanceState);\r\n        startBackgroundThread();\r\n    }\r\n\r\n    @Override\r\n    public void onResume() {\r\n        super.onResume();\r\n        startBackgroundThread();\r\n\r\n        // When the screen is turned off and turned back on, the SurfaceTexture is already\r\n        // available, and \"onSurfaceTextureAvailable\" will not be called. In that case, we can open\r\n        // a camera and start preview from here (otherwise, we wait until the surface is ready in\r\n        // the SurfaceTextureListener).\r\n        if (textureView.isAvailable()) {\r\n            openCamera(textureView.getWidth(), textureView.getHeight());\r\n        } else {\r\n            textureView.setSurfaceTextureListener(surfaceTextureListener);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void onPause() {\r\n        closeCamera();\r\n        stopBackgroundThread();\r\n        super.onPause();\r\n    }\r\n\r\n    @Override\r\n    public void onDestroy() {\r\n        if (classifier != null) {\r\n            classifier.close();\r\n        }\r\n        super.onDestroy();\r\n    }\r\n\r\n    /**\r\n     * Sets up member variables related to camera.\r\n     *\r\n     * @param width The width of available size for camera preview\r\n     * @param height The height of available size for camera preview\r\n     */\r\n    private void setUpCameraOutputs(int width, int height) {\r\n        Activity activity = getActivity();\r\n        CameraManager manager = (CameraManager) activity.getSystemService(Context.CAMERA_SERVICE);\r\n        try {\r\n            for (String cameraId : manager.getCameraIdList()) {\r\n                CameraCharacteristics characteristics = manager.getCameraCharacteristics(cameraId);\r\n\r\n                // We don't use a front facing camera in this sample.\r\n                Integer facing = characteristics.get(CameraCharacteristics.LENS_FACING);\r\n                if (facing != null && facing == CameraCharacteristics.LENS_FACING_FRONT) {\r\n                    continue;\r\n                }\r\n\r\n                StreamConfigurationMap map =\r\n                        characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);\r\n                if (map == null) {\r\n                    continue;\r\n                }\r\n\r\n                // // For still image captures, we use the largest available size.\r\n                Size largest =\r\n                        Collections.max(\r\n                                Arrays.asList(map.getOutputSizes(ImageFormat.JPEG)), new CompareSizesByArea());\r\n                imageReader =\r\n                        ImageReader.newInstance(\r\n                                largest.getWidth(), largest.getHeight(), ImageFormat.JPEG, /*maxImages*/ 2);\r\n\r\n                // Find out if we need to swap dimension to get the preview size relative to sensor\r\n                // coordinate.\r\n                int displayRotation = activity.getWindowManager().getDefaultDisplay().getRotation();\r\n                // noinspection ConstantConditions\r\n                /* Orientation of the camera sensor */\r\n                int sensorOrientation = characteristics.get(CameraCharacteristics.SENSOR_ORIENTATION);\r\n                boolean swappedDimensions = false;\r\n                switch (displayRotation) {\r\n                    case Surface.ROTATION_0:\r\n                    case Surface.ROTATION_180:\r\n                        if (sensorOrientation == 90 || sensorOrientation == 270) {\r\n                            swappedDimensions = true;\r\n                        }\r\n                        break;\r\n                    case Surface.ROTATION_90:\r\n                    case Surface.ROTATION_270:\r\n                        if (sensorOrientation == 0 || sensorOrientation == 180) {\r\n                            swappedDimensions = true;\r\n                        }\r\n                        break;\r\n                    default:\r\n                        Log.e(TAG, \"Display rotation is invalid: \" + displayRotation);\r\n                }\r\n\r\n                Point displaySize = new Point();\r\n                activity.getWindowManager().getDefaultDisplay().getSize(displaySize);\r\n                int rotatedPreviewWidth = width;\r\n                int rotatedPreviewHeight = height;\r\n                int maxPreviewWidth = displaySize.x;\r\n                int maxPreviewHeight = displaySize.y;\r\n\r\n                if (swappedDimensions) {\r\n                    rotatedPreviewWidth = height;\r\n                    rotatedPreviewHeight = width;\r\n                    maxPreviewWidth = displaySize.y;\r\n                    maxPreviewHeight = displaySize.x;\r\n                }\r\n\r\n                if (maxPreviewWidth > MAX_PREVIEW_WIDTH) {\r\n                    maxPreviewWidth = MAX_PREVIEW_WIDTH;\r\n                }\r\n\r\n                if (maxPreviewHeight > MAX_PREVIEW_HEIGHT) {\r\n                    maxPreviewHeight = MAX_PREVIEW_HEIGHT;\r\n                }\r\n\r\n                previewSize =\r\n                        chooseOptimalSize(\r\n                                map.getOutputSizes(SurfaceTexture.class),\r\n                                rotatedPreviewWidth,\r\n                                rotatedPreviewHeight,\r\n                                maxPreviewWidth,\r\n                                maxPreviewHeight,\r\n                                largest);\r\n\r\n                // We fit the aspect ratio of TextureView to the size of preview we picked.\r\n                int orientation = getResources().getConfiguration().orientation;\r\n                if (orientation == Configuration.ORIENTATION_LANDSCAPE) {\r\n                    textureView.setAspectRatio(previewSize.getWidth(), previewSize.getHeight());\r\n                } else {\r\n                    textureView.setAspectRatio(previewSize.getHeight(), previewSize.getWidth());\r\n                }\r\n\r\n                this.cameraId = cameraId;\r\n                return;\r\n            }\r\n        } catch (CameraAccessException e) {\r\n            Log.e(TAG, \"Failed to access Camera\", e);\r\n        } catch (NullPointerException e) {\r\n            // Currently an NPE is thrown when the Camera2API is used but not supported on the\r\n            // device this code runs.\r\n            ErrorDialog.newInstance(getString(R.string.camera_error))\r\n                    .show(getChildFragmentManager(), FRAGMENT_DIALOG);\r\n        }\r\n    }\r\n\r\n    private String[] getRequiredPermissions() {\r\n        Activity activity = getActivity();\r\n        try {\r\n            PackageInfo info =\r\n                    activity\r\n                            .getPackageManager()\r\n                            .getPackageInfo(activity.getPackageName(), PackageManager.GET_PERMISSIONS);\r\n            String[] ps = info.requestedPermissions;\r\n            if (ps != null && ps.length > 0) {\r\n                return ps;\r\n            } else {\r\n                return new String[0];\r\n            }\r\n        } catch (Exception e) {\r\n            return new String[0];\r\n        }\r\n    }\r\n\r\n    /** Opens the camera specified by {@link Camera2BasicFragment#cameraId}. */\r\n    private void openCamera(int width, int height) {\r\n        if (!checkedPermissions && !allPermissionsGranted()) {\r\n            FragmentCompat.requestPermissions(this, getRequiredPermissions(), PERMISSIONS_REQUEST_CODE);\r\n            return;\r\n        } else {\r\n            checkedPermissions = true;\r\n        }\r\n        setUpCameraOutputs(width, height);\r\n        configureTransform(width, height);\r\n        Activity activity = getActivity();\r\n        CameraManager manager = (CameraManager) activity.getSystemService(Context.CAMERA_SERVICE);\r\n        try {\r\n            if (!cameraOpenCloseLock.tryAcquire(2500, TimeUnit.MILLISECONDS)) {\r\n                throw new RuntimeException(\"Time out waiting to lock camera opening.\");\r\n            }\r\n            manager.openCamera(cameraId, stateCallback, backgroundHandler);\r\n        } catch (CameraAccessException e) {\r\n            Log.e(TAG, \"Failed to open Camera\", e);\r\n        } catch (InterruptedException e) {\r\n            throw new RuntimeException(\"Interrupted while trying to lock camera opening.\", e);\r\n        }\r\n    }\r\n\r\n    private boolean allPermissionsGranted() {\r\n        for (String permission : getRequiredPermissions()) {\r\n            if (getActivity().checkPermission(permission, Process.myPid(), Process.myUid())\r\n                    != PackageManager.PERMISSION_GRANTED) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public void onRequestPermissionsResult(\r\n            int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {\r\n        super.onRequestPermissionsResult(requestCode, permissions, grantResults);\r\n    }\r\n\r\n    /** Closes the current {@link CameraDevice}. */\r\n    private void closeCamera() {\r\n        try {\r\n            cameraOpenCloseLock.acquire();\r\n            if (null != captureSession) {\r\n                captureSession.close();\r\n                captureSession = null;\r\n            }\r\n            if (null != cameraDevice) {\r\n                cameraDevice.close();\r\n                cameraDevice = null;\r\n            }\r\n            if (null != imageReader) {\r\n                imageReader.close();\r\n                imageReader = null;\r\n            }\r\n        } catch (InterruptedException e) {\r\n            throw new RuntimeException(\"Interrupted while trying to lock camera closing.\", e);\r\n        } finally {\r\n            cameraOpenCloseLock.release();\r\n        }\r\n    }\r\n\r\n    /** Starts a background thread and its {@link Handler}. */\r\n    private void startBackgroundThread() {\r\n        backgroundThread = new HandlerThread(HANDLE_THREAD_NAME);\r\n        backgroundThread.start();\r\n        backgroundHandler = new Handler(backgroundThread.getLooper());\r\n        // Start the classification train & load an initial model.\r\n        synchronized (lock) {\r\n            runClassifier = true;\r\n        }\r\n        backgroundHandler.post(periodicClassify);\r\n        updateActiveModel();\r\n    }\r\n\r\n    /** Stops the background thread and its {@link Handler}. */\r\n    private void stopBackgroundThread() {\r\n        backgroundThread.quitSafely();\r\n        try {\r\n            backgroundThread.join();\r\n            backgroundThread = null;\r\n            backgroundHandler = null;\r\n            synchronized (lock) {\r\n                runClassifier = false;\r\n            }\r\n        } catch (InterruptedException e) {\r\n            Log.e(TAG, \"Interrupted when stopping background thread\", e);\r\n        }\r\n    }\r\n\r\n    /** Takes photos and classify them periodically. */\r\n    private Runnable periodicClassify =\r\n            new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    synchronized (lock) {\r\n                        if (runClassifier) {\r\n                            classifyFrame();\r\n                        }\r\n                    }\r\n                    backgroundHandler.post(periodicClassify);\r\n                }\r\n            };\r\n\r\n    /** Creates a new {@link CameraCaptureSession} for camera preview. */\r\n    private void createCameraPreviewSession() {\r\n        try {\r\n            SurfaceTexture texture = textureView.getSurfaceTexture();\r\n            assert texture != null;\r\n\r\n            // We configure the size of default buffer to be the size of camera preview we want.\r\n            texture.setDefaultBufferSize(previewSize.getWidth(), previewSize.getHeight());\r\n\r\n            // This is the output Surface we need to start preview.\r\n            Surface surface = new Surface(texture);\r\n\r\n            // We set up a CaptureRequest.Builder with the output Surface.\r\n            previewRequestBuilder = cameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);\r\n            previewRequestBuilder.addTarget(surface);\r\n\r\n            // Here, we create a CameraCaptureSession for camera preview.\r\n            cameraDevice.createCaptureSession(\r\n                    Arrays.asList(surface),\r\n                    new CameraCaptureSession.StateCallback() {\r\n\r\n                        @Override\r\n                        public void onConfigured(@NonNull CameraCaptureSession cameraCaptureSession) {\r\n                            // The camera is already closed\r\n                            if (null == cameraDevice) {\r\n                                return;\r\n                            }\r\n\r\n                            // When the session is ready, we start displaying the preview.\r\n                            captureSession = cameraCaptureSession;\r\n                            try {\r\n                                // Auto focus should be continuous for camera preview.\r\n                                previewRequestBuilder.set(\r\n                                        CaptureRequest.CONTROL_AF_MODE,\r\n                                        CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE);\r\n\r\n                                // Finally, we start displaying the camera preview.\r\n                                previewRequest = previewRequestBuilder.build();\r\n                                captureSession.setRepeatingRequest(\r\n                                        previewRequest, captureCallback, backgroundHandler);\r\n                            } catch (CameraAccessException e) {\r\n                                Log.e(TAG, \"Failed to set up config to capture Camera\", e);\r\n                            }\r\n                        }\r\n\r\n                        @Override\r\n                        public void onConfigureFailed(@NonNull CameraCaptureSession cameraCaptureSession) {\r\n                            showToast(\"Failed\");\r\n                        }\r\n                    },\r\n                    null);\r\n        } catch (CameraAccessException e) {\r\n            Log.e(TAG, \"Failed to preview Camera\", e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Configures the necessary {@link android.graphics.Matrix} transformation to `textureView`. This\r\n     * method should be called after the camera preview size is determined in setUpCameraOutputs and\r\n     * also the size of `textureView` is fixed.\r\n     *\r\n     * @param viewWidth The width of `textureView`\r\n     * @param viewHeight The height of `textureView`\r\n     */\r\n    private void configureTransform(int viewWidth, int viewHeight) {\r\n        Activity activity = getActivity();\r\n        if (null == textureView || null == previewSize || null == activity) {\r\n            return;\r\n        }\r\n        int rotation = activity.getWindowManager().getDefaultDisplay().getRotation();\r\n        Matrix matrix = new Matrix();\r\n        RectF viewRect = new RectF(0, 0, viewWidth, viewHeight);\r\n        RectF bufferRect = new RectF(0, 0, previewSize.getHeight(), previewSize.getWidth());\r\n        float centerX = viewRect.centerX();\r\n        float centerY = viewRect.centerY();\r\n        if (Surface.ROTATION_90 == rotation || Surface.ROTATION_270 == rotation) {\r\n            bufferRect.offset(centerX - bufferRect.centerX(), centerY - bufferRect.centerY());\r\n            matrix.setRectToRect(viewRect, bufferRect, Matrix.ScaleToFit.FILL);\r\n            float scale =\r\n                    Math.max(\r\n                            (float) viewHeight / previewSize.getHeight(),\r\n                            (float) viewWidth / previewSize.getWidth());\r\n            matrix.postScale(scale, scale, centerX, centerY);\r\n            matrix.postRotate(90 * (rotation - 2), centerX, centerY);\r\n        } else if (Surface.ROTATION_180 == rotation) {\r\n            matrix.postRotate(180, centerX, centerY);\r\n        }\r\n        textureView.setTransform(matrix);\r\n    }\r\n\r\n    /** Classifies a frame from the preview stream. */\r\n    private void classifyFrame() {\r\n        if (classifier == null || getActivity() == null || cameraDevice == null) {\r\n            // It's important to not call showToast every frame, or else the app will starve and\r\n            // hang. updateActiveModel() already puts an error message up with showToast.\r\n            // showToast(\"Uninitialized Classifier or invalid context.\");\r\n            return;\r\n        }\r\n        SpannableStringBuilder textToShow = new SpannableStringBuilder();\r\n        Bitmap bitmap = textureView.getBitmap(classifier.getImageSizeX(), classifier.getImageSizeY());\r\n        classifier.classifyFrame(bitmap, textToShow);\r\n        bitmap.recycle();\r\n        showToast(textToShow);\r\n    }\r\n\r\n    /** Compares two {@code Size}s based on their areas. */\r\n    private static class CompareSizesByArea implements Comparator<Size> {\r\n\r\n        @Override\r\n        public int compare(Size lhs, Size rhs) {\r\n            // We cast here to ensure the multiplications won't overflow\r\n            return Long.signum(\r\n                    (long) lhs.getWidth() * lhs.getHeight() - (long) rhs.getWidth() * rhs.getHeight());\r\n        }\r\n    }\r\n\r\n    /** Shows an error message dialog. */\r\n    public static class ErrorDialog extends DialogFragment {\r\n\r\n        private static final String ARG_MESSAGE = \"message\";\r\n\r\n        public static ErrorDialog newInstance(String message) {\r\n            ErrorDialog dialog = new ErrorDialog();\r\n            Bundle args = new Bundle();\r\n            args.putString(ARG_MESSAGE, message);\r\n            dialog.setArguments(args);\r\n            return dialog;\r\n        }\r\n\r\n        @Override\r\n        public Dialog onCreateDialog(Bundle savedInstanceState) {\r\n            final Activity activity = getActivity();\r\n            return new AlertDialog.Builder(activity)\r\n                    .setMessage(getArguments().getString(ARG_MESSAGE))\r\n                    .setPositiveButton(\r\n                            android.R.string.ok,\r\n                            new DialogInterface.OnClickListener() {\r\n                                @Override\r\n                                public void onClick(DialogInterface dialogInterface, int i) {\r\n                                    activity.finish();\r\n                                }\r\n                            })\r\n                    .create();\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/example/kodama/controllers/Camera2BasicFragment.java	(revision 887d8269f1a4c46160d95da2a13d574d16d3cf6c)
+++ app/src/main/java/com/example/kodama/controllers/Camera2BasicFragment.java	(date 1617902694991)
@@ -30,7 +30,7 @@
 import android.os.Handler;
 import android.os.HandlerThread;
 import android.os.Process;
-import android.support.annotation.NonNull;
+//import android.support.annotation.NonNull;
 import android.text.SpannableString;
 import android.text.SpannableStringBuilder;
 import android.util.Log;
@@ -48,6 +48,8 @@
 import android.widget.Toast;
 import android.support.v13.app.FragmentCompat;
 
+import androidx.annotation.NonNull;
+
 import com.example.kodama.view.AutoFitTextureView;
 
 import java.io.IOException;
@@ -61,7 +63,7 @@
 
 /** Basic fragments for the Camera. */
 public class Camera2BasicFragment extends Fragment
-        implements FragmentCompat.OnRequestPermissionsResultCallback {
+        implements Fragment.OnRequestPermissionsResultCallback {
 
     /** Tag for the {@link Log}. */
     private static final String TAG = "TfLiteCameraDemo";
